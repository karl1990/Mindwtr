name: Release Windows

on:
  workflow_call:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.2.3)'
        required: false
        type: string
      run_msstore:
        description: 'Run Microsoft Store publish steps even if this is not a tag push'
        required: false
        type: boolean
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.2.3)'
        required: false
        type: string
      run_msstore:
        description: 'Run Microsoft Store publish steps even if this is not a tag push'
        required: false
        type: boolean

permissions:
  contents: write

env:
  MS_IDENTITY_NAME: "DongdaLi.Mindwtr"
  MS_PUBLISHER_ID: "CN=76AC9B15-7A1B-49FF-9342-2BE80735A1E6"
  MS_PUBLISHER_DISPLAY_NAME: "Dongda Li"

jobs:
  windows:
    runs-on: windows-latest
    name: Windows Build (EXE + MSIX)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0"

      - name: Resolve version
        id: version
        shell: pwsh
        run: |
          $tag = "${{ inputs.tag }}"
          if (-not $tag) { $tag = "${{ github.event.inputs.tag }}" }
          if (-not $tag) { $tag = "${{ github.ref_name }}" }
          $version = $tag -replace '^v',''
          if (-not $version) { $version = "0.0.0" }
          $msixVersion = ($version.Split('.') + @('0','0','0','0'))[0..3] -join '.'
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "msix_version=$msixVersion" >> $env:GITHUB_OUTPUT

      - name: Build Tauri app
        run: |
          cd apps/desktop
          cargo tauri build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure MakeAppx is available
        shell: pwsh
        run: |
          $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "makeappx.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "\\x64\\makeappx.exe$" } |
            Select-Object -First 1 -ExpandProperty FullName
          if ($makeappx) {
            Write-Host "Found makeappx at $makeappx"
            exit 0
          }
          if (Get-Command winget -ErrorAction SilentlyContinue) {
            winget install --id Microsoft.WindowsSDK.10.0.22621 --silent --accept-package-agreements --accept-source-agreements
            exit 0
          }
          Write-Error "makeappx.exe not found and winget is unavailable."

      - name: Create MSIX layout
        shell: pwsh
        run: |
          $buildDir = "apps/desktop/src-tauri/target/release"
          $outDir = "msix-staging"
          $iconDir = "apps/desktop/src-tauri/icons"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          New-Item -ItemType Directory -Force -Path "$outDir\Assets" | Out-Null
          Copy-Item "$buildDir/mindwtr.exe" -Destination "$outDir/mindwtr.exe"
          if (Test-Path "$buildDir/WebView2Loader.dll") {
            Copy-Item "$buildDir/WebView2Loader.dll" -Destination "$outDir"
          }
          Copy-Item "$iconDir/Square44x44Logo.png" "$outDir\Assets\StoreLogo.png"
          Copy-Item "$iconDir/Square150x150Logo.png" "$outDir\Assets\Square150x150Logo.png"
          Copy-Item "$iconDir/Square44x44Logo.png" "$outDir\Assets\Square44x44Logo.png"

      - name: Generate AppxManifest.xml
        shell: pwsh
        run: |
          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10" 
                   xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10" 
                   xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">
            <Identity Name="$env:MS_IDENTITY_NAME" 
                      Publisher="$env:MS_PUBLISHER_ID" 
                      Version="${{ steps.version.outputs.msix_version }}" />
            <Properties>
              <DisplayName>Mindwtr</DisplayName>
              <PublisherDisplayName>$env:MS_PUBLISHER_DISPLAY_NAME</PublisherDisplayName>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-us" />
            </Resources>
            <Applications>
              <Application Id="App" Executable="mindwtr.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="Mindwtr" 
                                    Description="Local-first GTD application" 
                                    BackgroundColor="transparent" 
                                    Square150x150Logo="Assets\Square150x150Logo.png" 
                                    Square44x44Logo="Assets\Square44x44Logo.png">
                </uap:VisualElements>
              </Application>
            </Applications>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
          </Package>
          "@
          $manifest | Out-File -FilePath "msix-staging\AppxManifest.xml" -Encoding UTF8

      - name: Build MSIX package
        shell: pwsh
        run: |
          $msixPath = "mindwtr_${{ steps.version.outputs.version }}_x64.msix"
          $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "makeappx.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "\\x64\\makeappx.exe$" } |
            Select-Object -First 1 -ExpandProperty FullName
          if (-not $makeappx) {
            throw "makeappx.exe not found for x64"
          }
          & $makeappx pack /d msix-staging /p $msixPath /o

      - name: Setup Microsoft Store CLI
        uses: microsoft/setup-msstore-cli@v1

      - name: Validate Microsoft Store secrets
        if: startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_SELLER_ID: ${{ secrets.MS_SELLER_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          $required = @('MS_TENANT_ID','MS_SELLER_ID','MS_CLIENT_ID','MS_CLIENT_SECRET','MS_STORE_APP_ID')
          foreach ($name in $required) {
            if (-not (Get-Item -Path "env:$name" -ErrorAction SilentlyContinue)) {
              Write-Error "$name is missing. Please set it in repository secrets."
            }
          }

      - name: Reconfigure store credentials
        if: startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_SELLER_ID: ${{ secrets.MS_SELLER_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
        run: |
          msstore reconfigure `
            --tenantId $env:MS_TENANT_ID `
            --sellerId $env:MS_SELLER_ID `
            --clientId $env:MS_CLIENT_ID `
            --clientSecret $env:MS_CLIENT_SECRET

      - name: Check Microsoft Store submission status
        id: msstore_status
        if: startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true
        shell: pwsh
        env:
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          $statusOutput = & msstore submission status $env:MS_STORE_APP_ID 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Failed to check submission status. Continuing: $statusOutput"
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }
          if ($statusOutput -match 'Could not find a Pending Submission') {
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $statusText = ($statusOutput | Out-String)
          $status = ''
          $pendingMatch = [regex]::Match($statusText, 'Pending Submission.*?Submission Status\\s*=\\s*(\\w+)', 'Singleline')
          if ($pendingMatch.Success) {
            $status = $pendingMatch.Groups[1].Value
          } else {
            $statusMatch = [regex]::Match($statusText, 'Submission Status\\s*=\\s*(\\w+)')
            if ($statusMatch.Success) {
              $status = $statusMatch.Groups[1].Value
            }
          }
          $blockedStatuses = @('CommitStarted', 'PreProcessing', 'Certification', 'InCertification', 'PendingCommit', 'InProgress')
          $blockedRegex = '(?i)(CommitStarted|PreProcessing|Certification|InCertification|PendingCommit|InProgress|Pending[\s_-]*Submission)'
          $blocked = ($blockedStatuses -contains $status) -or ($statusText -match $blockedRegex)
          if ($blocked) {
            Write-Warning "Store submission in progress. Skipping Store update. Status: $statusText"
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }
          "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Update Microsoft Store metadata
        if: (startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true) && steps.msstore_status.outputs.skip != 'true'
        shell: pwsh
        env:
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          if (-not (Test-Path "metadata/metadata.json")) {
            Write-Warning "metadata/metadata.json not found. Skipping store metadata update."
            exit 0
          }
          $metadataRaw = Get-Content -Raw "metadata/metadata.json"
          $metadata = $metadataRaw | ConvertFrom-Json
          foreach ($prop in @('Id','PendingApplicationId','Status','StatusDetails','FileUploadUrl','PackageDeliveryOptions','FriendlyName','Trailers','GamingOptions')) {
            if ($metadata.PSObject.Properties.Name -contains $prop) {
              $metadata.PSObject.Properties.Remove($prop)
            }
          }
          $packagesJson = $null
          $submissionGetOutput = & msstore submission get $env:MS_STORE_APP_ID 2>&1
          if ($LASTEXITCODE -eq 0) {
            $submissionText = ($submissionGetOutput | Out-String)
            $keyIndex = $submissionText.IndexOf('"ApplicationPackages"')
            if ($keyIndex -ge 0) {
              $arrayStart = $submissionText.IndexOf('[', $keyIndex)
              if ($arrayStart -ge 0) {
                $depth = 0
                $inString = $false
                $escape = $false
                for ($i = $arrayStart; $i -lt $submissionText.Length; $i++) {
                  $ch = $submissionText[$i]
                  if ($inString) {
                    if ($escape) {
                      $escape = $false
                    } elseif ($ch -eq '\') {
                      $escape = $true
                    } elseif ($ch -eq '"') {
                      $inString = $false
                    }
                    continue
                  }
                  if ($ch -eq '"') {
                    $inString = $true
                    continue
                  }
                  if ($ch -eq '[') {
                    $depth += 1
                  } elseif ($ch -eq ']') {
                    $depth -= 1
                    if ($depth -eq 0) {
                      $packagesJson = $submissionText.Substring($arrayStart, $i - $arrayStart + 1)
                      break
                    }
                  }
                }
              }
            }
            if ($packagesJson) {
              $packagesJson = ($packagesJson -replace "`r?`n", "").Trim()
            } else {
              Write-Warning "Could not locate ApplicationPackages array in submission output."
            }
          } else {
            Write-Warning "Failed to fetch current submission packages: $submissionGetOutput"
          }
          if ($packagesJson) {
            $metadata.ApplicationPackages = "__PACKAGES__"
          } else {
            Write-Warning "ApplicationPackages missing; metadata update may fail."
            if ($metadata.PSObject.Properties.Name -contains 'ApplicationPackages') {
              $metadata.PSObject.Properties.Remove('ApplicationPackages')
            }
          }
          $ensureArray = {
            param($value)
            if ($null -eq $value) { return $value }
            if ($value -is [System.Array]) { return $value }
            return @($value)
          }
          if ($metadata.HardwarePreferences) {
            $metadata.HardwarePreferences = & $ensureArray $metadata.HardwarePreferences
          }
          if ($metadata.Listings) {
            foreach ($listingProp in $metadata.Listings.PSObject.Properties) {
              $listing = $listingProp.Value
              if (-not $listing) { continue }
              $baseListing = $listing.BaseListing
              if (-not $baseListing) { continue }
              foreach ($field in @('Keywords','Features','Images','RecommendedHardware','MinimumHardware')) {
                if ($baseListing.PSObject.Properties.Name -contains $field) {
                  $baseListing.$field = & $ensureArray $baseListing.$field
                }
              }
            }
          }
          $metadataJson = $metadata | ConvertTo-Json -Depth 100 -Compress
          if ($packagesJson) {
            $metadataJson = $metadataJson.Replace('"ApplicationPackages":"__PACKAGES__"', '"ApplicationPackages":' + $packagesJson)
          }
          $isStoreBusy = {
            param([string]$text)
            if ([string]::IsNullOrWhiteSpace($text)) { return $false }
            return $text -match '(?i)(InvalidState|CommitStarted|PreProcessing|Certification|InCertification|PendingCommit|InProgress|Pending[\s_-]*Submission|Another\s+submission|already\s+.*submission)'
          }
          $maxRetries = 3
          $delaySeconds = 30
          $success = $false
          for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
            Write-Host "Updating metadata (attempt $attempt of $maxRetries)..."
            $psi = [System.Diagnostics.ProcessStartInfo]::new()
            $psi.FileName = 'msstore'
            $psi.ArgumentList.Add('submission')
            $psi.ArgumentList.Add('updateMetadata')
            $psi.ArgumentList.Add($env:MS_STORE_APP_ID)
            $psi.ArgumentList.Add($metadataJson)
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.UseShellExecute = $false
            $process = [System.Diagnostics.Process]::Start($psi)
            $stdoutTask = $process.StandardOutput.ReadToEndAsync()
            $stderrTask = $process.StandardError.ReadToEndAsync()
            if (-not $process.WaitForExit(600000)) {
              $process.Kill()
              $updateOutput = "Metadata update timed out after 10 minutes"
              $exitCode = 124
            } else {
              $stdout = $stdoutTask.GetAwaiter().GetResult()
              $stderr = $stderrTask.GetAwaiter().GetResult()
              $updateOutput = ($stdout + $stderr).Trim()
              $exitCode = $process.ExitCode
            }
            if ($exitCode -eq 0) {
              $success = $true
              break
            }
            if (& $isStoreBusy $updateOutput) {
              Write-Warning "Store submission is in certification. Skipping metadata update."
              exit 0
            }
            $statusRecheckOutput = & msstore submission status $env:MS_STORE_APP_ID 2>&1
            if ($LASTEXITCODE -eq 0 -and (& $isStoreBusy ($statusRecheckOutput | Out-String))) {
              Write-Warning "Store submission moved into certification/in-progress state. Skipping metadata update. Status: $statusRecheckOutput"
              exit 0
            }
            if ($updateOutput -match '504' -or $updateOutput -match 'Gateway' -or $updateOutput -match 'timeout' -or $updateOutput -match 'timed out') {
              if ($attempt -lt $maxRetries) {
                Write-Warning "Store API timeout. Retrying in $delaySeconds seconds..."
                Start-Sleep -Seconds $delaySeconds
                $delaySeconds = [Math]::Min($delaySeconds * 2, 180)
                continue
              }
            }
            break
          }
          if (-not $success) {
            throw "Metadata update failed after $maxRetries attempts: $updateOutput"
          }

      - name: Publish to Microsoft Store
        if: (startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true) && steps.msstore_status.outputs.skip != 'true' && env.MSSTORE_SKIP_PUBLISH != 'true'
        shell: pwsh
        env:
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          $msix = (Resolve-Path "mindwtr_${{ steps.version.outputs.version }}_x64.msix").Path
          $isStoreBusy = {
            param([string]$text)
            if ([string]::IsNullOrWhiteSpace($text)) { return $false }
            return $text -match '(?i)(InvalidState|CommitStarted|PreProcessing|Certification|InCertification|PendingCommit|InProgress|Pending[\s_-]*Submission|Another\s+submission|already\s+.*submission)'
          }
          $isTransientStoreError = {
            param([string]$text)
            if ([string]::IsNullOrWhiteSpace($text)) { return $false }
            return $text -match '(?i)(\b50[0-9]\b|Gateway Timeout|Service unavailable|OriginTimeout|Azure Front Door|timed out|timeout|temporar(y|ily)|try again)'
          }
          $invokeMsstore = {
            param(
              [string[]]$args,
              [int]$timeoutMs
            )
            $psi = [System.Diagnostics.ProcessStartInfo]::new()
            $psi.FileName = 'msstore'
            foreach ($arg in $args) {
              $psi.ArgumentList.Add($arg)
            }
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.UseShellExecute = $false
            $process = [System.Diagnostics.Process]::Start($psi)
            $stdoutTask = $process.StandardOutput.ReadToEndAsync()
            $stderrTask = $process.StandardError.ReadToEndAsync()
            if (-not $process.WaitForExit($timeoutMs)) {
              $process.Kill()
              return [pscustomobject]@{
                ExitCode = 124
                Output = "Command timed out after $([Math]::Round($timeoutMs / 60000.0, 2)) minutes"
              }
            }
            $stdout = $stdoutTask.GetAwaiter().GetResult()
            $stderr = $stderrTask.GetAwaiter().GetResult()
            return [pscustomobject]@{
              ExitCode = $process.ExitCode
              Output = ($stdout + $stderr).Trim()
            }
          }

          $maxRetries = 5
          $delaySeconds = 30
          $updated = $false
          $updateOutput = ''

          # Upload package to the existing draft submission so metadata and package are committed together.
          for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
            Write-Host "Updating Microsoft Store draft submission package (attempt $attempt of $maxRetries)..."
            $updateResult = & $invokeMsstore @('submission', 'update', $env:MS_STORE_APP_ID, $msix) 900000
            $updateOutput = $updateResult.Output
            if ($updateResult.ExitCode -eq 0) {
              $updated = $true
              break
            }

            if (& $isStoreBusy $updateOutput) {
              Write-Warning "Store submission is already in certification/in-progress. Skipping publish."
              exit 0
            }

            $statusRecheckOutput = & msstore submission status $env:MS_STORE_APP_ID 2>&1
            if ($LASTEXITCODE -eq 0 -and (& $isStoreBusy ($statusRecheckOutput | Out-String))) {
              Write-Warning "Store submission moved into certification/in-progress state. Skipping publish. Status: $statusRecheckOutput"
              exit 0
            }

            if ((& $isTransientStoreError $updateOutput) -and $attempt -lt $maxRetries) {
              Write-Warning "Transient Store API error detected while updating package. Retrying in $delaySeconds seconds..."
              Start-Sleep -Seconds $delaySeconds
              $delaySeconds = [Math]::Min($delaySeconds * 2, 240)
              continue
            }

            break
          }

          if (-not $updated) {
            throw "Store package update failed after $maxRetries attempts: $updateOutput"
          }

          $delaySeconds = 30
          $published = $false
          $publishOutput = ''

          # Publish (commit) the same draft submission that now contains metadata + package updates.
          for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
            Write-Host "Publishing Microsoft Store draft submission (attempt $attempt of $maxRetries)..."
            $publishResult = & $invokeMsstore @('submission', 'publish', $env:MS_STORE_APP_ID) 900000
            $publishOutput = $publishResult.Output
            if ($publishResult.ExitCode -eq 0) {
              $published = $true
              break
            }

            if (& $isStoreBusy $publishOutput) {
              Write-Warning "Store submission is already in certification/in-progress. Skipping publish."
              exit 0
            }

            $statusRecheckOutput = & msstore submission status $env:MS_STORE_APP_ID 2>&1
            if ($LASTEXITCODE -eq 0 -and (& $isStoreBusy ($statusRecheckOutput | Out-String))) {
              Write-Warning "Store submission moved into certification/in-progress state. Skipping publish. Status: $statusRecheckOutput"
              exit 0
            }

            if ((& $isTransientStoreError $publishOutput) -and $attempt -lt $maxRetries) {
              Write-Warning "Transient Store API error detected while publishing submission. Retrying in $delaySeconds seconds..."
              Start-Sleep -Seconds $delaySeconds
              $delaySeconds = [Math]::Min($delaySeconds * 2, 240)
              continue
            }

            break
          }

          if (-not $published) {
            throw "Store submission publish failed after $maxRetries attempts: $publishOutput"
          }

      - name: Collect Windows artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path release-artifacts | Out-Null
          Get-ChildItem "apps/desktop/src-tauri/target/release/bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            $lower = $_.Name.ToLower()
            Copy-Item $_.FullName "release-artifacts/$lower"
          }
          Get-ChildItem "apps/desktop/src-tauri/target/release/bundle/msi/*.msi" -ErrorAction SilentlyContinue | ForEach-Object {
            $lower = $_.Name.ToLower()
            Copy-Item $_.FullName "release-artifacts/$lower"
          }
          Get-ChildItem "mindwtr_*.msix" -ErrorAction SilentlyContinue | ForEach-Object {
            Copy-Item $_.FullName "release-artifacts/$($_.Name.ToLower())"
          }
          Get-ChildItem release-artifacts

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-windows
          path: release-artifacts/*
          if-no-files-found: warn

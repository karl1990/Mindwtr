name: Release macOS App Store

on:
  workflow_call:
    inputs:
      upload:
        description: Upload to App Store Connect
        required: false
        type: boolean
        default: true
      submit_for_review:
        description: Submit build for review after upload
        required: false
        type: boolean
        default: true
      testflight_group:
        description: TestFlight external group for review-blocked uploads
        required: false
        type: string
        default: 'external_testing'
  workflow_dispatch:
    inputs:
      upload:
        description: Upload to App Store Connect
        required: false
        type: boolean
        default: true
      submit_for_review:
        description: Submit build for review after upload
        required: false
        type: boolean
        default: true
      testflight_group:
        description: TestFlight external group for review-blocked uploads
        required: false
        type: string
        default: 'external_testing'

permissions:
  contents: read

concurrency:
  group: release-macos-appstore-${{ github.ref }}
  cancel-in-progress: true

jobs:
  macos-appstore:
    runs-on: macos-15
    timeout-minutes: 90
    env:
      EXPECTED_BUNDLE_ID: tech.dongdongbh.mindwtr
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@09a7688d3b55cf0e976497ff046b70949eeaccfd # v1
        with:
          ruby-version: '3.3'

      - name: Install Fastlane
        run: gem install fastlane --no-document

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@631a55b12751854ce901bb631d5902ceb48146f7 # stable
        with:
          targets: aarch64-apple-darwin

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2
        with:
          workspaces: apps/desktop/src-tauri

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@3d267786b128fe76c2f16a390aa2448b815359f3 # v2
        with:
          bun-version: "1.x"

      - name: Install dependencies
        run: bun install

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0"

      - name: Validate required secrets
        env:
          MAS_CERTIFICATE: ${{ secrets.MAS_CERTIFICATE }}
          MAS_CERTIFICATE_BASE64: ${{ secrets.MAS_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          MAS_CERTIFICATE_PWD: ${{ secrets.MAS_CERTIFICATE_PWD }}
          MAS_CERTIFICATE_PASSWORD: ${{ secrets.MAS_CERTIFICATE_PASSWORD }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          MAS_INSTALLER_CERTIFICATE: ${{ secrets.MAS_INSTALLER_CERTIFICATE }}
          MAS_INSTALLER_CERT_PWD: ${{ secrets.MAS_INSTALLER_CERT_PWD }}
          MAS_INSTALLER_CERT_PASSWORD: ${{ secrets.MAS_INSTALLER_CERT_PASSWORD }}
          MAS_PROVISIONING_PROFILE: ${{ secrets.MAS_PROVISIONING_PROFILE }}
          MAS_SIGNING_IDENTITY: ${{ secrets.MAS_SIGNING_IDENTITY }}
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          CERT_B64="${MAS_CERTIFICATE:-${MAS_CERTIFICATE_BASE64:-${APPLE_CERTIFICATE:-}}}"
          CERT_PWD="${MAS_CERTIFICATE_PWD:-${MAS_CERTIFICATE_PASSWORD:-${APPLE_CERTIFICATE_PASSWORD:-}}}"
          INSTALLER_CERT_B64="${MAS_INSTALLER_CERTIFICATE:-}"
          INSTALLER_CERT_PWD="${MAS_INSTALLER_CERT_PWD:-${MAS_INSTALLER_CERT_PASSWORD:-}}"
          missing=0
          for key in MAS_PROVISIONING_PROFILE MAS_SIGNING_IDENTITY; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required secret: $key"
              missing=1
            fi
          done
          for key in IOS_ASC_KEY_ID IOS_ASC_ISSUER_ID IOS_ASC_PRIVATE_KEY; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required App Store Connect API secret: $key"
              missing=1
            fi
          done
          if [ -z "${CERT_B64:-}" ]; then
            echo "::error::Missing signing certificate secret. Set MAS_CERTIFICATE (or MAS_CERTIFICATE_BASE64)."
            missing=1
          fi
          if [ -z "${INSTALLER_CERT_B64:-}" ]; then
            echo "::error::Missing installer certificate secret. Set MAS_INSTALLER_CERTIFICATE."
            missing=1
          fi
          if [ -z "${CERT_PWD:-}" ]; then
            echo "::warning::No certificate password secret found (MAS_CERTIFICATE_PWD / MAS_CERTIFICATE_PASSWORD / APPLE_CERTIFICATE_PASSWORD)."
            echo "::warning::This is valid only if the exported .p12 has an empty password."
          fi
          if [ -z "${INSTALLER_CERT_PWD:-}" ]; then
            echo "::warning::No installer certificate password secret found (MAS_INSTALLER_CERT_PWD / MAS_INSTALLER_CERT_PASSWORD)."
            echo "::warning::This is valid only if the installer .p12 has an empty password."
          fi
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Import Mac App Store certificates
        env:
          MAS_CERTIFICATE: ${{ secrets.MAS_CERTIFICATE }}
          MAS_CERTIFICATE_BASE64: ${{ secrets.MAS_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          MAS_CERTIFICATE_PWD: ${{ secrets.MAS_CERTIFICATE_PWD }}
          MAS_CERTIFICATE_PASSWORD: ${{ secrets.MAS_CERTIFICATE_PASSWORD }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          MAS_INSTALLER_CERTIFICATE: ${{ secrets.MAS_INSTALLER_CERTIFICATE }}
          MAS_INSTALLER_CERT_PWD: ${{ secrets.MAS_INSTALLER_CERT_PWD }}
          MAS_INSTALLER_CERT_PASSWORD: ${{ secrets.MAS_INSTALLER_CERT_PASSWORD }}
        run: |
          set -euo pipefail
          APP_CERT_B64="${MAS_CERTIFICATE:-${MAS_CERTIFICATE_BASE64:-${APPLE_CERTIFICATE:-}}}"
          APP_CERT_PWD="${MAS_CERTIFICATE_PWD:-${MAS_CERTIFICATE_PASSWORD:-${APPLE_CERTIFICATE_PASSWORD:-}}}"
          INSTALLER_CERT_B64="${MAS_INSTALLER_CERTIFICATE:-}"
          INSTALLER_CERT_PWD="${MAS_INSTALLER_CERT_PWD:-${MAS_INSTALLER_CERT_PASSWORD:-}}"
          KEYCHAIN_PATH="$RUNNER_TEMP/mindwtr-mas.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 24)"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
          if [ -f "$LOGIN_KEYCHAIN" ]; then
            security list-keychains -d user -s "$KEYCHAIN_PATH" "$LOGIN_KEYCHAIN" "/Library/Keychains/System.keychain"
          else
            security list-keychains -d user -s "$KEYCHAIN_PATH" "/Library/Keychains/System.keychain"
          fi
          security default-keychain -s "$KEYCHAIN_PATH"

          APP_CERT_PATH="$RUNNER_TEMP/mas-app-signing.p12"
          if ! printf '%s' "$APP_CERT_B64" | tr -d '\r' | base64 --decode > "$APP_CERT_PATH" 2>/dev/null; then
            printf '%s' "$APP_CERT_B64" | tr -d '\r' | base64 -D > "$APP_CERT_PATH"
          fi

          INSTALLER_CERT_PATH="$RUNNER_TEMP/mas-installer-signing.p12"
          if ! printf '%s' "$INSTALLER_CERT_B64" | tr -d '\r' | base64 --decode > "$INSTALLER_CERT_PATH" 2>/dev/null; then
            printf '%s' "$INSTALLER_CERT_B64" | tr -d '\r' | base64 -D > "$INSTALLER_CERT_PATH"
          fi

          if ! openssl pkcs12 -in "$APP_CERT_PATH" -passin "pass:${APP_CERT_PWD:-}" -nokeys -clcerts >/dev/null 2>&1; then
            echo "::error::Unable to open the decoded .p12 with the provided password."
            echo "::error::Re-export your Apple Distribution certificate as .p12 and update the matching password secret."
            exit 1
          fi

          if ! openssl pkcs12 -in "$INSTALLER_CERT_PATH" -passin "pass:${INSTALLER_CERT_PWD:-}" -nokeys -clcerts >/dev/null 2>&1; then
            echo "::error::Unable to open installer .p12 with the provided password."
            echo "::error::Re-export your Mac Installer Distribution certificate as .p12 and update MAS_INSTALLER_CERT_PWD."
            exit 1
          fi

          security import "$APP_CERT_PATH" -k "$KEYCHAIN_PATH" -P "${APP_CERT_PWD:-}" -A -T /usr/bin/codesign -T /usr/bin/security
          security import "$INSTALLER_CERT_PATH" -k "$KEYCHAIN_PATH" -P "${INSTALLER_CERT_PWD:-}" -A -T /usr/bin/productbuild -T /usr/bin/pkgbuild -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productbuild:,pkgbuild: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security find-identity -v -p basic "$KEYCHAIN_PATH" || true

      - name: Install provisioning profile
        env:
          MAS_PROVISIONING_PROFILE: ${{ secrets.MAS_PROVISIONING_PROFILE }}
        run: |
          set -euo pipefail
          PROFILE_PATH="$RUNNER_TEMP/mindwtr-mas.provisionprofile"
          if ! echo "$MAS_PROVISIONING_PROFILE" | base64 --decode > "$PROFILE_PATH" 2>/dev/null; then
            echo "$MAS_PROVISIONING_PROFILE" | base64 -D > "$PROFILE_PATH"
          fi

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PROFILE_PATH" "$HOME/Library/MobileDevice/Provisioning Profiles/mindwtr-mas.provisionprofile"
          cp "$PROFILE_PATH" apps/desktop/src-tauri/embedded.provisionprofile

      - name: Resolve macOS version metadata
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
        run: |
          set -euo pipefail

          APP_VERSION="$(jq -r '.version // empty' apps/desktop/src-tauri/tauri.conf.json)"
          if [ -z "${APP_VERSION}" ]; then
            echo "::error::Missing version in apps/desktop/src-tauri/tauri.conf.json"
            exit 1
          fi

          LOCAL_MIN_BUILD=1
          EXISTING_BUNDLE_VERSION="$(jq -r '.bundle.macOS.bundleVersion // empty' apps/desktop/src-tauri/tauri.appstore.conf.json)"
          if [[ "${EXISTING_BUNDLE_VERSION}" =~ ^[0-9]+$ ]]; then
            LOCAL_MIN_BUILD="$((EXISTING_BUNDLE_VERSION + 1))"
          fi

          APPSTORE_APP_ID=""
          REMOTE_MAX_BUILD=0
          REMOTE_LOOKUP_STATUS="skipped"

          ASC_KEY_ID="$(printf '%s' "$IOS_ASC_KEY_ID" | tr -d '\r\n\t ')"
          ASC_ISSUER_ID="$(printf '%s' "$IOS_ASC_ISSUER_ID" | tr -d '\r\n\t ')"
          KEY_PATH="$RUNNER_TEMP/macos-asc-key-versioning.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$KEY_PATH"

          if ! openssl pkey -in "$KEY_PATH" -noout >/dev/null 2>&1; then
            echo "::warning::IOS_ASC_PRIVATE_KEY is not a valid .p8 key; skipping remote build-number lookup."
            REMOTE_LOOKUP_STATUS="invalid_key"
          else
            ASC_API_TMP_PREFIX="asc-macos-versioning"
            source scripts/ci/asc-api-utils.sh

            if ! ASC_TOKEN="$(
              node scripts/ci/generate-asc-jwt.js "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$KEY_PATH"
            )"; then
              echo "::warning::Failed to generate App Store Connect JWT from IOS_ASC_* secrets."
              REMOTE_LOOKUP_STATUS="invalid_jwt"
            fi

            APP_LOOKUP_JSON_FILE="$RUNNER_TEMP/asc-macos-app-lookup.json"
            if [ "${REMOTE_LOOKUP_STATUS}" != "invalid_jwt" ]; then
              if api_get "$APP_LOOKUP_JSON_FILE" -G \
                -H "Authorization: Bearer ${ASC_TOKEN}" \
                --data-urlencode "filter[bundleId]=${EXPECTED_BUNDLE_ID}" \
                --data-urlencode "limit=1" \
                "https://api.appstoreconnect.apple.com/v1/apps"; then
                APPSTORE_APP_ID="$(jq -r '.data[0].id // empty' "$APP_LOOKUP_JSON_FILE")"
                if [ -n "${APPSTORE_APP_ID}" ]; then
                  BUILDS_JSON_FILE="$RUNNER_TEMP/asc-macos-builds-page.json"
                  if api_get "$BUILDS_JSON_FILE" -G \
                    -H "Authorization: Bearer ${ASC_TOKEN}" \
                    --data-urlencode "filter[app]=${APPSTORE_APP_ID}" \
                    --data-urlencode "limit=200" \
                    "https://api.appstoreconnect.apple.com/v1/builds"; then
                    while : ; do
                      PAGE_MAX="$(jq -r '[.data[]?.attributes.version | select(type=="string") | select(test("^[0-9]+$")) | tonumber] | max // 0' "$BUILDS_JSON_FILE")"
                      if [ "${PAGE_MAX}" -gt "${REMOTE_MAX_BUILD}" ]; then
                        REMOTE_MAX_BUILD="${PAGE_MAX}"
                      fi
                      NEXT_URL="$(jq -r '.links.next // empty' "$BUILDS_JSON_FILE")"
                      if [ -z "${NEXT_URL}" ]; then
                        REMOTE_LOOKUP_STATUS="ok"
                        break
                      fi
                      if ! api_get "$BUILDS_JSON_FILE" -g -H "Authorization: Bearer ${ASC_TOKEN}" "$NEXT_URL"; then
                        REMOTE_LOOKUP_STATUS="api_error"
                        break
                      fi
                    done
                  else
                    REMOTE_LOOKUP_STATUS="api_error"
                  fi
                else
                  echo "::warning::App Store Connect app lookup returned no app for bundle id ${EXPECTED_BUNDLE_ID}."
                  REMOTE_LOOKUP_STATUS="no_app"
                fi
              else
                REMOTE_LOOKUP_STATUS="api_error"
              fi
            fi
          fi

          REMOTE_MIN_BUILD="$((REMOTE_MAX_BUILD + 1))"
          FINAL_BUILD_NUMBER="${LOCAL_MIN_BUILD}"
          if [ "${REMOTE_MIN_BUILD}" -gt "${FINAL_BUILD_NUMBER}" ]; then
            FINAL_BUILD_NUMBER="${REMOTE_MIN_BUILD}"
          fi

          echo "APP_VERSION=${APP_VERSION}" >> "$GITHUB_ENV"
          echo "APP_BUILD_NUMBER=${FINAL_BUILD_NUMBER}" >> "$GITHUB_ENV"
          echo "APPSTORE_APP_ID=${APPSTORE_APP_ID:-}" >> "$GITHUB_ENV"
          echo "Resolved macOS build number: ${FINAL_BUILD_NUMBER} (remote max: ${REMOTE_MAX_BUILD}, remote lookup: ${REMOTE_LOOKUP_STATUS}, local floor: ${LOCAL_MIN_BUILD})"

          APPSTORE_CONFIG_PATH="apps/desktop/src-tauri/tauri.appstore.conf.json"
          APP_BUILD_NUMBER="${FINAL_BUILD_NUMBER}" APPSTORE_CONFIG_PATH="${APPSTORE_CONFIG_PATH}" node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const filePath = path.resolve(process.env.APPSTORE_CONFIG_PATH);
          const buildNumber = process.env.APP_BUILD_NUMBER;
          const config = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          config.bundle = config.bundle || {};
          config.bundle.macOS = config.bundle.macOS || {};
          config.bundle.macOS.bundleVersion = String(buildNumber);
          fs.writeFileSync(filePath, JSON.stringify(config, null, 2) + '\n');
          console.log(`Updated ${filePath} bundle.macOS.bundleVersion -> ${buildNumber}`);
          NODE

      - name: Build signed macOS app bundle (App Store)
        timeout-minutes: 30
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.MAS_SIGNING_IDENTITY }}
          VITE_ANALYTICS_HEARTBEAT_URL: ${{ secrets.ANALYTICS_HEARTBEAT_URL }}
          CFLAGS: -march=armv8.5-a+i8mm
          CXXFLAGS: -march=armv8.5-a+i8mm
          CMAKE_C_FLAGS: -march=armv8.5-a+i8mm
          CMAKE_CXX_FLAGS: -march=armv8.5-a+i8mm
          TAURI_LOG_LEVEL: debug
        run: |
          set -euo pipefail
          cd apps/desktop
          cargo tauri build \
            --target aarch64-apple-darwin \
            --bundles app \
            --config src-tauri/tauri.appstore.conf.json

      - name: Build signed installer package
        timeout-minutes: 8
        env:
          MAS_INSTALLER_IDENTITY: ${{ secrets.MAS_INSTALLER_IDENTITY }}
          MAS_INSTALLER_SIGNING_IDENTITY: ${{ secrets.MAS_INSTALLER_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          if [ -z "${KEYCHAIN_PATH:-}" ] || [ -z "${KEYCHAIN_PASSWORD:-}" ]; then
            echo "::error::Missing keychain env from previous step (KEYCHAIN_PATH/KEYCHAIN_PASSWORD)."
            exit 1
          fi
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
          if [ -f "$LOGIN_KEYCHAIN" ]; then
            security list-keychains -d user -s "$KEYCHAIN_PATH" "$LOGIN_KEYCHAIN" "/Library/Keychains/System.keychain"
          else
            security list-keychains -d user -s "$KEYCHAIN_PATH" "/Library/Keychains/System.keychain"
          fi
          security default-keychain -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productbuild:,pkgbuild: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          APP_PATH="$(find apps/desktop/src-tauri/target/aarch64-apple-darwin/release/bundle/macos -maxdepth 1 -name '*.app' | head -n 1)"
          if [ -z "${APP_PATH:-}" ]; then
            echo "::error::Built .app bundle not found"
            exit 1
          fi

          INSTALLER_IDENTITY="${MAS_INSTALLER_IDENTITY:-${MAS_INSTALLER_SIGNING_IDENTITY:-}}"
          if [ -z "${INSTALLER_IDENTITY:-}" ]; then
            INSTALLER_IDENTITY="$(security find-identity -v -p basic "${KEYCHAIN_PATH}" | sed -n 's/.*\"\\(3rd Party Mac Developer Installer:.*\\)\".*/\\1/p' | head -n 1)"
          fi
          if [ -z "${INSTALLER_IDENTITY:-}" ]; then
            INSTALLER_IDENTITY="$(security find-identity -v -p basic "${KEYCHAIN_PATH}" | sed -n 's/.*\"\\(Mac Installer Distribution:.*\\)\".*/\\1/p' | head -n 1)"
          fi
          if [ -z "${INSTALLER_IDENTITY:-}" ]; then
            echo "::error::Missing installer identity. Set MAS_INSTALLER_IDENTITY (or MAS_INSTALLER_SIGNING_IDENTITY) or import a Mac Installer Distribution certificate."
            exit 1
          fi
          if [[ "$INSTALLER_IDENTITY" != *Installer* ]]; then
            echo "::error::Installer identity must be an installer certificate, got: $INSTALLER_IDENTITY"
            echo "::error::Use MAS_INSTALLER_IDENTITY with value like '3rd Party Mac Developer Installer: ...'."
            exit 1
          fi
          if ! security find-identity -v -p basic "${KEYCHAIN_PATH}" | grep -F "\"$INSTALLER_IDENTITY\"" >/dev/null; then
            echo "::error::Installer identity not found in keychain: $INSTALLER_IDENTITY"
            echo "::error::Verify MAS_INSTALLER_CERTIFICATE/MAS_INSTALLER_CERT_PWD match this identity."
            exit 1
          fi
          echo "Using installer identity: $INSTALLER_IDENTITY"

          APP_BUNDLE_DIR="$(dirname "$APP_PATH")"
          BUNDLE_DIR="$(dirname "$APP_BUNDLE_DIR")"
          PKG_DIR="$BUNDLE_DIR/pkg"
          PKG_PATH="$PKG_DIR/Mindwtr-mac-appstore.pkg"
          mkdir -p "$PKG_DIR"

          APP_INFO_PLIST="$APP_PATH/Contents/Info.plist"
          APP_VERSION="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$APP_INFO_PLIST")"
          APP_BUILD_NUMBER="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$APP_INFO_PLIST")"
          if [ -z "${APP_VERSION:-}" ] || [ -z "${APP_BUILD_NUMBER:-}" ]; then
            echo "::error::Failed to resolve app version/build from $APP_INFO_PLIST"
            exit 1
          fi

          xcrun productbuild \
            --keychain "$KEYCHAIN_PATH" \
            --component "$APP_PATH" /Applications \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_PATH"

          echo "APP_VERSION=$APP_VERSION" >> "$GITHUB_ENV"
          echo "APP_BUILD_NUMBER=$APP_BUILD_NUMBER" >> "$GITHUB_ENV"
          echo "PKG_PATH=$PKG_PATH" >> "$GITHUB_ENV"
          ls -la "$PKG_DIR"

      - name: Upload package artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: mindwtr-macos-appstore-pkg
          path: ${{ env.PKG_PATH }}
          if-no-files-found: error

      - name: Prepare Fastlane metadata
        if: ${{ inputs.upload }}
        env:
          RELEASE_BODY: ${{ github.event.release.body || '' }}
          APP_SUPPORT_URL: "https://github.com/dongdongbh/Mindwtr/issues"
          APP_MARKETING_URL: "https://github.com/dongdongbh/Mindwtr"
        run: |
          set -euo pipefail

          export FASTLANE_METADATA_DIR="$RUNNER_TEMP/fastlane_metadata"
          scripts/ci/prepare-fastlane-metadata.sh
          echo "FASTLANE_METADATA_PATH=$FASTLANE_METADATA_DIR" >> "$GITHUB_ENV"

      - name: Resolve App Store review submission flag
        if: ${{ inputs.upload }}
        timeout-minutes: 10
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          REQUESTED_SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review && 'true' || 'false' }}
        run: |
          set -euo pipefail

          EFFECTIVE_SUBMIT_FOR_REVIEW="${REQUESTED_SUBMIT_FOR_REVIEW:-true}"
          REQUESTED_SUBMIT_FOR_REVIEW="$EFFECTIVE_SUBMIT_FOR_REVIEW"
          if [ "$REQUESTED_SUBMIT_FOR_REVIEW" != "true" ]; then
            REQUESTED_SUBMIT_FOR_REVIEW="false"
            EFFECTIVE_SUBMIT_FOR_REVIEW="false"
            echo "Review submission disabled by input; checking App Store review state for TestFlight external routing."
          fi
          echo "ENABLE_TESTFLIGHT_EXTERNAL_RELEASE=false" >> "$GITHUB_ENV"
          echo "SKIP_APP_VERSION_UPDATE_FOR_UPLOAD=false" >> "$GITHUB_ENV"

          if [ -z "${IOS_ASC_KEY_ID:-}" ] || [ -z "${IOS_ASC_ISSUER_ID:-}" ] || [ -z "${IOS_ASC_PRIVATE_KEY:-}" ]; then
            echo "::warning::App Store Connect API secrets are missing. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ASC_KEY_ID="$(printf '%s' "$IOS_ASC_KEY_ID" | tr -d '\r\n\t ')"
          ASC_ISSUER_ID="$(printf '%s' "$IOS_ASC_ISSUER_ID" | tr -d '\r\n\t ')"
          ASC_KEY_PATH="$RUNNER_TEMP/macos-asc-key-review-check.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          if ! openssl pkey -in "$ASC_KEY_PATH" -noout >/dev/null 2>&1; then
            echo "::warning::IOS_ASC_PRIVATE_KEY is invalid. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ASC_API_TMP_PREFIX="asc-review"
          source scripts/ci/asc-api-utils.sh

          if ! ASC_TOKEN="$(
            node scripts/ci/generate-asc-jwt.js "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$ASC_KEY_PATH"
          )"; then
            echo "::warning::Failed to generate App Store Connect JWT. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          APPSTORE_APP_ID_RESOLVED=""
          APP_LOOKUP_JSON_FILE="$RUNNER_TEMP/asc-review-app-lookup.json"
          if api_get "$APP_LOOKUP_JSON_FILE" -G \
            -H "Authorization: Bearer ${ASC_TOKEN}" \
            --data-urlencode "filter[bundleId]=${EXPECTED_BUNDLE_ID}" \
            --data-urlencode "limit=1" \
            "https://api.appstoreconnect.apple.com/v1/apps"; then
            APPSTORE_APP_ID_RESOLVED="$(jq -r '.data[0].id // empty' "$APP_LOOKUP_JSON_FILE")"
          fi

          if [ -z "${APPSTORE_APP_ID_RESOLVED}" ]; then
            echo "::warning::App lookup returned no App Store Connect app. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          REVIEW_JSON_FILE="$RUNNER_TEMP/asc-review-versions.json"
          if ! api_get "$REVIEW_JSON_FILE" -G \
            -H "Authorization: Bearer ${ASC_TOKEN}" \
            --data-urlencode "filter[appStoreState]=WAITING_FOR_REVIEW,IN_REVIEW" \
            --data-urlencode "filter[platform]=MAC_OS" \
            --data-urlencode "limit=1" \
            "https://api.appstoreconnect.apple.com/v1/apps/${APPSTORE_APP_ID_RESOLVED}/appStoreVersions"; then
            echo "::warning::Review-state lookup failed. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ACTIVE_REVIEW_ID="$(jq -r '.data[0].id // empty' "$REVIEW_JSON_FILE")"
          ACTIVE_REVIEW_VERSION="$(jq -r '.data[0].attributes.versionString // empty' "$REVIEW_JSON_FILE")"
          ACTIVE_REVIEW_STATE="$(jq -r '.data[0].attributes.appStoreState // empty' "$REVIEW_JSON_FILE")"
          if [ -n "${ACTIVE_REVIEW_ID}" ]; then
            echo "::warning::Found existing macOS App Store submission in state ${ACTIVE_REVIEW_STATE:-unknown} (version ${ACTIVE_REVIEW_VERSION:-unknown}). Upload will proceed, but review submission is disabled."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            echo "ENABLE_TESTFLIGHT_EXTERNAL_RELEASE=true" >> "$GITHUB_ENV"
            echo "SKIP_APP_VERSION_UPDATE_FOR_UPLOAD=true" >> "$GITHUB_ENV"
            echo "SKIP_METADATA_FOR_UPLOAD=true" >> "$GITHUB_ENV"
            exit 0
          fi

          if [ "$REQUESTED_SUBMIT_FOR_REVIEW" = "true" ]; then
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=true" >> "$GITHUB_ENV"
            echo "No active App Store review submission found; review submission remains enabled."
          else
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            echo "No active App Store review submission found; submit_for_review remains disabled."
          fi

      - name: Upload package to App Store Connect
        if: ${{ inputs.upload }}
        timeout-minutes: 30
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          SUBMIT_FOR_REVIEW: ${{ env.EFFECTIVE_SUBMIT_FOR_REVIEW || 'false' }}
          SKIP_APP_VERSION_UPDATE: ${{ env.SKIP_APP_VERSION_UPDATE_FOR_UPLOAD || 'false' }}
          SKIP_METADATA: ${{ env.SKIP_METADATA_FOR_UPLOAD || 'false' }}
          FASTLANE_SKIP_UPDATE_CHECK: "1"
          FASTLANE_HIDE_CHANGELOG: "1"
          FASTLANE_OPT_OUT_USAGE: "1"
          CI: "true"
        run: |
          set -euo pipefail

          if [ -z "${PKG_PATH:-}" ] || [ ! -f "$PKG_PATH" ]; then
            echo "::error::PKG file not found: ${PKG_PATH:-<empty>}"
            exit 1
          fi

          ASC_KEY_PATH="$RUNNER_TEMP/macos-asc-key-fastlane.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          mkdir -p fastlane
          cat <<'EOF' > fastlane/Fastfile
          opt_out_usage
          default_platform(:mac)

          platform :mac do
            lane :upload_app_store do
              api_key = app_store_connect_api_key(
                key_id: ENV.fetch("IOS_ASC_KEY_ID"),
                issuer_id: ENV.fetch("IOS_ASC_ISSUER_ID"),
                key_filepath: ENV.fetch("ASC_KEY_PATH"),
                duration: 1200,
                in_house: false
              )

              deliver(
                api_key: api_key,
                platform: "osx",
                pkg: ENV.fetch("PKG_PATH"),
                metadata_path: ENV.fetch("FASTLANE_METADATA_PATH"),
                skip_metadata: ENV.fetch("SKIP_METADATA", "false") == "true",
                skip_screenshots: true,
                skip_app_version_update: ENV.fetch("SKIP_APP_VERSION_UPDATE", "false") == "true",
                force: true,
                run_precheck_before_submit: false,
                submit_for_review: ENV.fetch("SUBMIT_FOR_REVIEW", "false") == "true",
                automatic_release: true
              )
            end
          end
          EOF

          ASC_KEY_PATH="$ASC_KEY_PATH" fastlane mac upload_app_store

      - name: Distribute upload to TestFlight external group
        if: ${{ inputs.upload }}
        timeout-minutes: 30
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          TESTFLIGHT_EXTERNAL_GROUP: ${{ inputs.testflight_group || 'external_testing' }}
          FASTLANE_SKIP_UPDATE_CHECK: "1"
          FASTLANE_HIDE_CHANGELOG: "1"
          FASTLANE_OPT_OUT_USAGE: "1"
          CI: "true"
        run: |
          set -euo pipefail

          ASC_KEY_PATH="$RUNNER_TEMP/macos-asc-key-fastlane-testflight.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          WHAT_TO_TEST_FILE="metadata/en-US/release_notes.txt"
          DEFAULT_WHAT_TO_TEST="Bug fixes, performance improvements, and sync stability updates."
          WHAT_TO_TEST=""
          if [ -f "$WHAT_TO_TEST_FILE" ]; then
            WHAT_TO_TEST="$(tr '\n' ' ' < "$WHAT_TO_TEST_FILE" | sed 's/[[:space:]]\+/ /g; s/^ //; s/ $//')"
          fi
          if [ -z "${WHAT_TO_TEST}" ]; then
            WHAT_TO_TEST="$DEFAULT_WHAT_TO_TEST"
          fi
          export TESTFLIGHT_WHAT_TO_TEST="$WHAT_TO_TEST"
          echo "Using TestFlight What to Test: ${TESTFLIGHT_WHAT_TO_TEST}"

          mkdir -p fastlane
          cat <<'EOF' > fastlane/Fastfile
          opt_out_usage

          lane :distribute_external_group do
            api_key = app_store_connect_api_key(
              key_id: ENV.fetch("IOS_ASC_KEY_ID"),
              issuer_id: ENV.fetch("IOS_ASC_ISSUER_ID"),
              key_filepath: ENV.fetch("ASC_KEY_PATH"),
              duration: 1200,
              in_house: false
            )

            upload_to_testflight(
              api_key: api_key,
              app_identifier: ENV.fetch("EXPECTED_BUNDLE_ID"),
              app_platform: "osx",
              distribute_only: true,
              app_version: ENV.fetch("APP_VERSION"),
              build_number: ENV.fetch("APP_BUILD_NUMBER"),
              distribute_external: true,
              groups: [ENV.fetch("TESTFLIGHT_EXTERNAL_GROUP")],
              notify_external_testers: false,
              changelog: ENV.fetch("TESTFLIGHT_WHAT_TO_TEST"),
              submit_beta_review: true,
              skip_submission: false,
              skip_waiting_for_build_processing: false,
              wait_processing_timeout_duration: 1800
            )
          rescue => e
            if e.message.include?("Another build is in review")
              UI.important("Another TestFlight build is already in beta review; retrying distribution with submit_beta_review disabled so group assignment can still succeed.")
              upload_to_testflight(
                api_key: api_key,
                app_identifier: ENV.fetch("EXPECTED_BUNDLE_ID"),
                app_platform: "osx",
                distribute_only: true,
                app_version: ENV.fetch("APP_VERSION"),
                build_number: ENV.fetch("APP_BUILD_NUMBER"),
                distribute_external: true,
                groups: [ENV.fetch("TESTFLIGHT_EXTERNAL_GROUP")],
                notify_external_testers: false,
                changelog: ENV.fetch("TESTFLIGHT_WHAT_TO_TEST"),
                submit_beta_review: false,
                skip_submission: false,
                skip_waiting_for_build_processing: false,
                wait_processing_timeout_duration: 1800
              )
            else
              raise e
            end
          end
          EOF

          echo "Distributing macOS build ${APP_VERSION} (${APP_BUILD_NUMBER}) to TestFlight group: ${TESTFLIGHT_EXTERNAL_GROUP}"
          ASC_KEY_PATH="$ASC_KEY_PATH" fastlane distribute_external_group

      - name: Cleanup signing files
        if: always()
        run: |
          rm -rf fastlane || true
          rm -f apps/desktop/src-tauri/embedded.provisionprofile
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "${KEYCHAIN_PATH}" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
